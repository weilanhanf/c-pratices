### 指针和地址
在程序中定义一个变量，在编译时就给这个变量分配一个内存单元，同时根据变量类型决定这个内存单元的大小。
如：整型2字节，实型4字节。

内存中每一个字节都有一个编号，就是地址。

对每一个变量，他在内存中都有一个存储位置，这个位置就是该变量的地址，对变量值的存取是通过地址进行。
在C语言中这个地址被形象的成为指针。

指针：一个变量的地址
指针变量：存放 

### 变量的指针和指向变量的指针变量


#### &和*
&：取地址运算符，取变量的地址。
* ：指针运算符，取指针所指向变量的内容。

### 数组和指针

* 数组的指针：数组的起始地址
* 数组元素的指针：数组元素的地址
* 引用数组元素：
    * 下标法：a[3]
    * 指针法：用指针变量指向所找的数组元素。占用内存少，速度快。 

#### 指向数组元素的指针
```
int a[10];
int *p;
p=&a[0]; 或p=a; //定义后赋值，两者等价；
```
定义指针变量时赋初值
```
int *p=&a[0];
int *p=a;
```
不能把一个整数赋值给指针变量，也不能把指针变量的值赋值给整型变量的值。

使用指针变量时要考虑的问题：

* p++的合法性，因为p是指针变量，++只能用于变量。a++不合法，因为a十四数组名，其值是数组元素的首地址，是常量，程序运行期间值固定不变。
* 指针变量使用时要注意当前值。
* p++，使得p指向下一个元素a[1]，则* p值为a[1]
* ++和*优先级同为2，结合性从右到左，* p++等价于*(p++)
*     * （p++）与* （++p）作用不同，* （p++)是先取* p的值，p在加1；* （++p）是p先加1，再取* p；如p初值为&a[0]，则* （p++)得a[0]的值，*(++p)得a[1]值。
* (* p)++表示p所指的元素值加1
* 如果p指向a[i]元素，则* (p--)相当于a[i--]，先对p进行* 运算再使得p自减。* (++p)相当于a[++i]，先使得p自加1，再作* 运算。

#### 数组名作为函数参数
数组名作为函数参数，是地址传递。
当用数组名做函数实参时相当于将数组的首地址传给被调函数的形参，此时，形参数组和实参数组占用的是同一段内存，所以当在被调函数的形参数组元素进行修改的时候，实参数组中的数据也将被修改。因为他们是同一地址。

1. 实参和形参都用数组名
```
inv(int x[], int n)

int a[10]; 
inv(a, 10);
```
2. 实参用数组名，形参用指针变量
```
inv(int *x, int n)

int a[10]; 
inv(a, 10);
```
3. 形参和实参都用指针变量
```
inv(int *x, int n)

int a[10];  
int *p=a;
inv(p, 10);
```
4. 实参用指针变量，形参用数组名
```
inv(int x[], int n)

int a[10];  
int *p=a;
inv(p, 10);
```


### 字符串与指针
#### 字符串的表示形式
#### 用字符指针实现

* 字符串的指针就是字符串的首地址，即第一个字符的地址，可以使用字符指针变量来保存这个地址。
* 使用字符指针可以处理字符串
* 字符指针的定义及使用
    * 定义初始化char *string="come on"
    * 在程序中可以直接把字符串常量赋值给一个指针变量char *string; string="come on";

字符指针变量在接受键入字符串时，必须先开辟空间（赋地址）
```
char str[10]; scanf("%s", str);  对
char *cp; scanf("%s", cp); 错
char *cp, str[10]; cp=str; scanf("%s", cp);
```

**字符指针常量**不能改变
**字符指针变量**值可以改变

  
### 指向函数的指针
用函数指针变量调用函数
函数指针：函数在编译时被分配的入口地址，用函数名表示，函数指针指向的是函数代码的存储区。
函数指针变量定义形式：
数据类型 （* 指针变量名）（）；
如int(* p)();
函数指针变量赋值：如p=max；
函数调用形式：c=max(a,b)<=>c=(* p)(a,b)
对函数指针变量做运算p++等无意义


### 返回指针值的函数

### 指针数组和指向指针的指针
用于处理二维数组，或者多个字符串
定义：数组中的每个元素都是指针变量
定义形式：存储类型 类型名 * 数组名[数组长度]  int * p[4];


### 有关指针的数组类型和指针运算的小结